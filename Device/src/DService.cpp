
/*  Â© Copyright CERN, 2015. All rights not expressly granted are reserved.

    The stub of this file was generated by quasar (https://github.com/quasar-team/quasar/)

    Quasar is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public Licence as published by
    the Free Software Foundation, either version 3 of the Licence.
    Quasar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public Licence for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with Quasar.  If not, see <http://www.gnu.org/licenses/>.


 */


#include <Configuration.hxx> // TODO; should go away, is already in Base class for ages

#include <DService.h>
#include <ASService.h>
#include <cstdlib>

namespace Device
{
// 1111111111111111111111111111111111111111111111111111111111111111111111111
// 1     GENERATED CODE STARTS HERE AND FINISHES AT SECTION 2              1
// 1     Users don't modify this code!!!!                                  1
// 1     If you modify this code you may start a fire or a flood somewhere,1
// 1     and some human being may possible cease to exist. You don't want  1
// 1     to be charged with that!                                          1
// 1111111111111111111111111111111111111111111111111111111111111111111111111






// 2222222222222222222222222222222222222222222222222222222222222222222222222
// 2     SEMI CUSTOM CODE STARTS HERE AND FINISHES AT SECTION 3            2
// 2     (code for which only stubs were generated automatically)          2
// 2     You should add the implementation but dont alter the headers      2
// 2     (apart from constructor, in which you should complete initializati2
// 2     on list)                                                          2
// 2222222222222222222222222222222222222222222222222222222222222222222222222

/* sample ctr */
DService::DService (
    const Configuration::Service& config,
    Parent_DService* parent
):
    Base_DService( config, parent)

    /* fill up constructor initialization list here */
{
    /* fill up constructor body here */
	host_url = config.url();
	LOG(Log::INF) << "Trying to ping: " << host_url;

}

/* sample dtr */
DService::~DService ()
{
}

/* delegates for cachevariables */



/* delegators for methods */

// 3333333333333333333333333333333333333333333333333333333333333333333333333
// 3     FULLY CUSTOM CODE STARTS HERE                                     3
// 3     Below you put bodies for custom methods defined for this class.   3
// 3     You can do whatever you want, but please be decent.               3
// 3333333333333333333333333333333333333333333333333333333333333333333333333
void DService::update(){
    LOG(Log::DBG) << "Running update()...";

    // Check if host_url is valid
    if (host_url.empty()) {
        LOG(Log::ERR) << "Host URL is empty!";
        getAddressSpaceLink()->setPing_time(-1, OpcUa_BadInvalidArgument);
        getAddressSpaceLink()->setPing_state(false, OpcUa_BadInvalidArgument);
        return;
    }

    // Build the ping command to send 1 packet
    std::string cmd = "ping -c 1 " + host_url + " 2>&1";

    // Buffer to read ping output
    std::array<char, 128> buffer;
    std::string result;

    // Open the pipe
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(cmd.c_str(), "r"), pclose);
    if (!pipe) {
        LOG(Log::ERR) << "popen failed!";
        getAddressSpaceLink()->setPing_time(-1, OpcUa_BadInternalError);
        getAddressSpaceLink()->setPing_state(false, OpcUa_BadDataUnavailable);
        return;
    }

    // Read ping output
    while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) {
        result += buffer.data();
    }

    // Log the raw ping output for debugging
    LOG(Log::DBG) << "Raw ping output: " << result;

    // Look for "time=" in the output
    auto pos = result.find("time=");
    if (pos == std::string::npos) {
        LOG(Log::ERR) << "\"time=\" not found in ping output.";
        getAddressSpaceLink()->setPing_time(-1, OpcUa_BadDataUnavailable);
        getAddressSpaceLink()->setPing_state(false, OpcUa_Good);
        return;
    }

    // Extract ping time value
    auto ms_start = pos + 5;
    auto ms_end = result.find(" ms", ms_start);
    if (ms_end == std::string::npos) {
        LOG(Log::ERR) << "\" ms\" not found after time= in ping output.";
        getAddressSpaceLink()->setPing_time(-1, OpcUa_BadDataUnavailable);
        getAddressSpaceLink()->setPing_state(false, OpcUa_Good);
        return;
    }

    std::string time_str = result.substr(ms_start, ms_end - ms_start);

    try {
        double ping_time_ms = std::stod(time_str);

        // Send to address space
        getAddressSpaceLink()->setPing_time(static_cast<OpcUa_Double>(ping_time_ms), OpcUa_Good);
        getAddressSpaceLink()->setPing_state(true, OpcUa_Good);

        LOG(Log::INF) << "Ping successful: " << ping_time_ms << " ms";
    } catch (...) {
        LOG(Log::ERR) << "Failed to convert ping time string: " << time_str;
        getAddressSpaceLink()->setPing_time(-1, OpcUa_BadDataUnavailable);
        getAddressSpaceLink()->setPing_state(false, OpcUa_Good);
    }
}

}
